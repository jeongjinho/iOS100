# DataStructures in Swift



## Collection

### iterator

한글로 반복기라고 불리는데, 즉, 반복할 수있도록 하는 것입니다. 이것을 사용하기위해서는 `IteratorProtocol` 프로토콜을 준수하면 가능합니다. 이 프로토콜는 next()을 구현해야합니다. 

아래 코드는 `IteratorProtocol` 을 준수하는 구조체 예제입니다.

```swift
struct TestIterator: IteratorProtocol {
    typealias Element = Int
    
    mutating func next() -> Int? {
     // decribe what next element   
    }
}
```



### sequence

시퀸스 타입을 따르면 `for in ` 문을 사용할 수있도록합니다.  시퀸스 타입은 `Sequence` 프로토콜을 따른 것을 말합니다.

시퀸스는 일단 컬렉션타입 반복기를 반복하는 것을 말합니다.  `sequence`  프로토콜 중에는 `makeInterator()` 라는 메서드가 있는데 이 메서드가 반복기를 순회하는 것 입니다. 해당 메서드는 직접 부르지 않고 for in문을 사용할때 자동적으로 불립니다.



### Collection

 컬렉션은 `Collection` 프로토콜을 따르는 타입입니다.  이 프로토콜은 `sequence` 프로토콜과 `Indexable` 프로토콜을 준수하는 프로토콜입니다.  또한 이 프로토콜이 준수해야하는 것중에는 `startIndex`, `endIndex` 를 정의하고, `index(after:)` ,서브스크립트 등을 정의해야 합니다.



## Stack



스택은 나중에 들어온게 먼저 나가는 구조입니다. 마치 팬케이크 겹겹히 쌓여있는 모양을 생각하면 편합니다. 여기서 팬케이를 먹을 때 맨위 부터 먹는다고 생각하면 됩니다!



스택에서 하는 동작들이 몆가지 있습니다.

- Push

  푸쉬동작은 스택에 해당 요소를 넣는 것을 말합니다. 위치는 가장 마지막에 넣어지게 됩니다.

  이 동작을 할 때에는 어떤 요소를 넣을지도 알고 있어야합니다.

- pop 

  팝 동작은 스택에서 어떠한 요소를 빼내는 것을 말합니다.

  팬케이크에서 맨윗장을 가져오는것을 말합니다. 팝동작 후에는 어떤 요소인지 알수 있도록 팝한 요소를 반환하도록해야 합니다.

- Peak

  이 동작은 해당 스택에 가장 마지막이 무엇인지 보는 것입니다. 여기서 팝과 다른점은 팝은 꺼내서 보기 때문에 팝 후에는 스택에 해당 요소가 없지만 peak동작은 해당 스택을 위에서 들여다보는 것이기 때문에  어떤 요소인지는 알 수 있지만 스택에서 내용이 바뀌지는 않습니다.

- full

   해당 동작은 오버플로우를 막기위해서 쓰는 동작입니다. 넣기 전에 해당 스택이 꽉찬 상태인지 아닌지를 판별하여 오버플로우가 발생하는 것을 막습니다.

- empty

  이 동작은 언더플로우를 막기위해서 쓰는 동작입니다.  팝하기 전에 스택이 비어있는지 확인할 때 사용합니다. 만약 비어있다면  팝동작을 하지 않을 것 입니다.



## Queue

큐는 먼저들어온 것이 먼저나가는 것입니다. 가장 간단한 개념의 자료구조이기도 한데요. 마트 계산대를 생각하면  먼저 줄선 사람이 먽 계산하고 집가는 것과 같습니다.

큐에서 필요한 동작들을  알아보겠습니다.

- enqueue

  enqueue는 큐에 요소를 넣는 것을 말합니다. Ex) 마트에서 뒤로 차례차례 줄을 서서 기다리게 하는 것과 같습니다.

- Dequeue

  dequeue는 큐에서 요소를 빼내는 것을 말합니다. 마트에서 줄을 기다리는 사람들중에 먼저 온 사람부터 계산하고 집으로 돌려 보내는 것이죠!

- peek

  이건 큐에서 현재가 가장 첫번째 요소가 무엇인지 알고 싶을 때 사용합니다. Ex) 현재 계산할 사람이 누군지 알아보기 때문에 고객이 계산대에서 빠져나가진 않습니다.

- clear

  큐에 있는 요소들을 모두 비우는 것을 말합니다. Ex) 계산점원이 해당 계산대가 마감했다고 모든 손님을 계산대에서 나가게 하는 것으로 비유할 수 있습니다.

- isFull 

  큐에 요소들이 꽉찼는지 알아보는 것입니다. 꽉찼다면 true를 반환하고 아니라면 false를 반환 할 것 입니다.

- isEmpty

  isFull과 반대로 큐가 비어있는지 아닌지를 확인할 때 쓰입니다. 비어있다면 true 아니라면 false,

- count

   현재 큐에 들어가 있는 요소들의 갯수를 반환합니다. Ex) 현재 계산대에 서 있는 손님들의 수를 반환합니다.





## Ring Buffer

링버퍼 즉 순환버퍼라는 것은 큐를 변형한 자료구조입니다. 자료구조가 링모양이란 것은 아니지만 논리적으로 보면 그렇다는 건데..

즉 마지막까지큐가 채워지면 그 다음 채워지는 곳은 맨앞이 됩니다. 그렇기 때문에 맨뒤가 맨앞을 아는 모양이다보니 두개가 맞닿아 있는 링구조로 생각해볼 수 있습니다.

### 구현 특징

일단 이 큐는 고정크기를 가지고 있습니다.

그리고 제가 만들 링버퍼는 용량이 2거듭제곱으로 늘어나고 그밖에 값이들어오면 가까운 2거듭제곱 값으로 변환해줄 것입니다.

링퍼버는 값이 꽉찼다면 가장오래된 것으로부터 덮어쓰는것과, 무시하는 것 두가지 동작을 할 수 있도록 하겠습니다.





링버퍼에서 필요한 동작들을  알아보겠습니다.

- enqueue

  해당 데이터를 링버퍼도 큐이다보니 맨뒤에다 놓습니다. 다만 다 차있는 경우는 가장 오랫동안 큐에 있던 요소를 하나 뺍니다.

  버퍼의 용량까지 요소가 채워져있다면 해당 용량으로 나누어서 나오는 나머지에 값을 집어넣습니다.

- dequeue

   버퍼에서 가장 오래된 요소를 빼냅니다. 가장 앞이 가장오래된 요소인지는 알 수 없습니다.

  요소를 반환 후에는 해당 포인터가 한칸뒤로 가리키게 됩니다. 다만 한칸뒤가 버퍼의 용량보다 크다면 용량으로 나눈 나머지로 포인터가 이동하게 됩니다.

- peek

  해당 버퍼에서 가장 오래된 요소를 반환합니다. 반환만하지 포인트가 다음을 가리키진 않습니다.

- isFull

   해당 버퍼가 가득차있는지 알아볼 수 있습니다. enqueue할 때 쓰입니다. 그냥도 쓰이고요..

- isEmpty

  해당 버퍼가 비어있는지 알아볼 수 있습니다. dequeue할 때  쓰입니다. 그냥도 쓰입니다 

