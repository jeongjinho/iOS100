# Generic



이 책이 첫 출간 후에 프로토콜 지향 프로그래밍에 대한 많은 질문을 들을 받았습니다.

대부분의 피드백은 매우 긍정적이였습니다. 그러나  저는 한번의 세미나를 열기도 했죠. 거기서 매우똑독한 사람들 중 한명과  얘기를 나눌 수 있었는데요.  그가 한말중 하나는 내가 제네릭프로그래밍을 잊지말아야 한다는 것이였습니다.

그  저는 제네릭프로그래밍에 대한 얘기에서 저는 꼼짝할 수 없었고 운이좋게 이 새로운 버전에서 쓸 수 있게 되었습니다.  

이번 챕터에서 배울 내용은

-  제네릭이 무엇인지
- 어떻게 제네릭 함수를 만들 수 있는지
- 어떻게 제네릭 서브크립트를 사용할 수 있는지
- 어떻게 카피온라이트르가 구현되는지
- 어떻게 유연가능하고 재사용가능한 타입을 프로토콜과 제네릭을 통해서 만들 수 있는지



제네릭은  코드의 중복을 피하고, 유연하고 재사용성 좋은 코드를 만들 수 있게 해줍니다.  타입보장 언어 즉 스위프트에서, 우리는 자주 다수의 타입에 대해 유효한 함수나 타입을 작성합니다.  우리가 두개의 값을 교환할 때 필요할 수도 있습니다. 예를 들어 두개의 문자열 타입을 교환하거나 두개의 정수형타입을 교환 할 때 쓰일 수 있습니다.  제네릭을 사용하지 않는다면, 우리는 3개의 분리된 함수를 작성해야합니다.  제네릭에서는, 우리는 오직 다른타입에 대해 하나의  교환할 수 있는 제네릭 함수만 작성하면 됩니다



*제네릭은 함수 또는 타입을 알려달라고한다. 나는 스위프트가  타입이 안전한 언어라는 것을 안다 하지만 나는 이게 왜 필요한지는 모른다. 나는 너에게 플레이스홀더타입만을 줄 뿐이다.  그리고 너는 그 타입을 런타임에서 정할 것이다.*

 

이것을 깨달을지 그렇지 못할지는 모르지만, 제네릭은 스위프트로 짠 모든 프로그램에서 매우 큰 부분을 차지하고 있습니다.  스위프트 자체에서 제네릭이 큰 부분을 차지하기 때문입니다.

우리는 제네릭이 스위프트 표준라이브러리에서 쓰이는지 볼 수 있는 예제인 배열을 예로 들 수 있습니다.

제닉은 타입 또는 인스턴스를 포함한 배열을 생성 할 수 있도록 합니다.

옵셔널은 또다른 스위프트언어에서 제네릭을 사용하는 예입니다.  옵셔널 타입은 `None`   과 `Some(T)` 열거형으로 정의되어 있습니다. `T` 는 예상되는 타입을 연관값으로 가지고 있습니다. 만약 옵셔널이 nil로 넣어진다면  None을 가지게 될 것이고, 만약 옵셔널이 넣어지게 된다면  연관값인 Some의 값을 가지게 됩니다. 내부적으로, 옵셔널은 아래처럼 정의되어 있습니다.

```swift
enum Optional<T> {
    case None
    case Some(T)
}
```

여기 T는 옵셔널의 연관 타입입니다.  T 플레이스홀더는 제네릭으로  정의되어 사용되어 질 것 입니다.  이 챕터 에서 우리는 대부분 T 플레이스홀더를 사용하겠지만  우리는 T 또는 E로도 표현할 수있습니다. 이 두개가 표준 문서에서 사용중이기 때문입니다.

스위프트에서 우리는 제네릭함수와 제네릭 타입을 두개를 정의 할 수 있습니다. 자 어떻게 제네릭 함수를 구현하지는 보시죠!

### Generic functions



제네릭을 완벽히 이해하기 위해서,  우리는  저들이 제시한 문제를 풀기위한 이해가 필요합니다.  자 저희는  두 변수의 값을 교환하는 함수를 만들어야 합니다. 

그러나 어플레케이션에서 우리는 두 정수타입의 인스턴스값과, 두 문자열타입의 인스턴스, 실수들을 교환하여야 합니다.

제네릭이 없다면, 아래와 같이 세개의 코드가 만들어질 것입니다.

```swift
func swapInts (a: inout Int, b: inout Int) {
    let tmp = a
    a = b
    b = tmp
}

func swapDoubles(a: inout Double, b: inout Double) {
    let tmp = a
    a = b
    b = tmp
}

func swapStrings(a: inout String, b: inout String) {
    let tmp = a
    a = b
    b = tmp
} 
```

